package Offer10;

public class Solution {
    /**
     * 和LeetCode70相同，是跳台阶问题
     * 动态规划
     * 淦，因为本题
     * 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
     * 所以输出上面需要更改
     *
     * 为什么要取余
     * 大数越界： 随着 nn 增大, f(n)f(n) 会超过 Int32 甚至 Int64 的取值范围，导致最终的返回值错误。
     * 求余运算规则： 设正整数 x, y, p ，求余符号为 ⊙ ，则有 (x+y)⊙ p = ( x⊙p + y⊙p ) ⊙ p 。
     * 解析：根据以上规则，可推出 f(n)⊙p=[f(n−1)⊙p+f(n−2)⊙p]⊙p ，从而可以在循环过程中每次计算 sum=a+b⊙1000000007 ，此操作与最终返回前取余等价。
     *
     */
//    public int numWays(int n) {
//        // 取模后，0和1都是1
//        if(n <= 1)
//            return 1;
//        // 最后一阶台阶与前一阶和前两阶有关
//        // dp表示每一节台阶的跳法
//        int[] dp = new int[n+1];
//        dp[0] = 1;
//        dp[1] = 1;
//        dp[2] = 2;
//        for (int i = 3; i < n+1; i ++){
//            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007;
//        }
//        return dp[n] ;
//    }

    /**
     * 空间复杂度优化
     * 由于 dp 列表第 i 项只与第 i-1 和第 i-2 项有关，因此只需要初始化三个整形变量 sum, a, b ，
     * 利用辅助变量 sum 使 a, b 两数字交替前进即可 （具体实现见代码） 。
     * 因为节省了 dp 列表空间，因此空间复杂度降至 O(1)O(1) 。
     */

    public int numWays(int n) {
        // 只用两个值循环交替
        int a = 1, b = 1, sum;
        for(int i = 0; i < n; i++){
            sum = (a + b) % 1000000007;
            a = b;
            b = sum;
        }
        return a;
    }
}
