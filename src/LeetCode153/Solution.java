package LeetCode153;

import java.util.Arrays;

public class Solution {
    /**
     * 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
     * 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
     * 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
     * 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。
     *
     * 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。
     *
     * 也就是一个数组，前半段是升序，然后到了最小元素（原先的开头），然后降低，后半段也是升序，但是后半段的最大值小于前半段的最小值
     *
     * 其实用一个最简单的排序，然后取最小值就可以通过了
     *
     * 但是这种还是用巧妙的方法，也就是二分查找法
     * 用二分法查找，需要始终将目标值（这里是最小值）套住，并不断收缩左边界或右边界
     * 左值 < 中值, 中值 < 右值 ：没有旋转，最小值在最左边，可以收缩右边界
     * 左值 > 中值, 中值 < 右值 ：有旋转，最小值在左半边，可以收缩右边界
     * 左值 < 中值, 中值 > 右值 ：有旋转，最小值在右半边，可以收缩左边界
     * 左值 > 中值, 中值 > 右值 ：单调递减，不可能出现
     */
//    public int findMin(int[] nums) {
//        Arrays.sort(nums);
//        return nums[0];
//    }
    public int findMin(int[] nums) {
        int left = 0;
        // 左闭右闭区间，如果用右开区间则不方便判断右值
        int right = nums.length - 1;
        while (left < right){
            // 求中间值
            int mid = left + (right - left) / 2;
            // 中值 > 右值，最小值在右半边，收缩左边界
            if (nums[mid] > nums[right]){
                // 因为中值 > 右值，中值肯定不是最小值，左边界可以跨过mid
                left = mid + 1;
            }else{ // 明确中值 < 右值，最小值在左半边，收缩右边界
                // 因为中值 < 右值，中值也可能是最小值，右边界只能取到mid处
                right = mid;
            }
        }
        return nums[left];
    }

}
