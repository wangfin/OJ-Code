package LeetCode486;

public class Solution {
    /**
     * 给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。
     * 每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。
     *
     * 给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。
     * 输入：[1, 5, 2]
     * 输出：False
     * 解释：一开始，玩家1可以从1和2中进行选择。
     * 如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。
     * 所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。
     * 因此，玩家 1 永远不会成为赢家，返回 False 。
     *
     * 题解用的是动态规划，想到贪婪和回溯，贪婪感觉没啥问题吧，回溯可以求出全部解，但是还是动态规划直接一些
     * 动态规划的没看懂啥意思，还是用的评论中的对递归方法的改进
     *
     * 也就是选择与轮次无关，他只选择这一轮中的最优选择
     * 首先，这题有一个标签是极小化极大（Minimax），带这个标签的题目并不多，但通常有一个范式：
     * A，B轮流进行某种决策，且决策间是相互竞争关系。假定A先进行决策。
     * A，B都符合理性人假设。更确切地说，每一次决策都会选出当前最优的方案（而不会在意已经做过的决策）。
     * 1和2共同反映了极小化极大（Minimax）的定义，即此消彼长——第一轮A决策极大化A自己的收益，同时间接极小化了B的收益；第二轮B则相反，如此往复；
     * 2间接确保了最优子结构的存在。仔细思考会发现这里面有一件事是重复进行的，那就是决策本身——决策者只有两个可能的决策，并且他会选择让自己优势最大化的那个。
     *
     */
    public boolean PredictTheWinner(int[] nums) {
        // 比较
        // start从头，end从尾
        return play(nums, 0, nums.length - 1) >= 0;
        // play(nums, lo, hi)这个函数可以认为是“从[lo, hi]这个区间里，我能获取的最大分值”，这个“我”不限于A或B；
        // 但是B拿走了10分，对于A自然就是-10分；反之亦然。这就是那个“-”号的最真实体现。
    }

    private int play(int[] nums, int lo, int hi){
        // 问题规模缩小，数组中没有可以选择的元素
        if (lo > hi)
            return 0;
        // A 的选择会让B的选择的收益下降
        int planA = nums[lo] - play(nums, lo + 1, hi);
        int planB = nums[hi] - play(nums, lo, hi - 1);
        return Math.max(planA, planB);
    }

}
